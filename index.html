<!DOCTYPE html>

<title>The most minimal pastebin in the world.</title>

<style>
	*, *:before, *:after {
		box-sizing: border-box;
		padding: 0;
		margin: 0;
		tab-size: 4;
		overflow: auto;
		outline: none;
	}
	
	body { font: 14px "Helvetica Neue", Helvetica, sans-serif; background-color: #eee; color: #333; }
	body, form { padding: 15px; }
	textarea { font: 16px 'Hasklug Nerd Font Mono', 'Hasklug NF', 'Hasklug Nerd Font', Hasklig, Monofur, monospace; width: 100%; resize: none; background-color: transparent; border: none; overflow: hidden; color: #222; }
	form { background-color: #ddd; }
	p { margin: 10px 0 15px; }
	summary { margin-bottom: 10px; }
	
	.badged[data-remaining] { position: relative; }
	.badged[data-remaining]:after {
		content: attr(data-remaining) " / " attr(data-limit);
		display: inline-block;
		position: absolute;
		bottom: 1ex;
		right: 1ex;
		padding: 0.25ex 0.5ex;
		pointer-events: none;  /* We aren't interact-able, pass through! */
		background-color: rgba(127,127,127,0.75);
		color: #555;
		font-size: 0.8em;
		font-weight: bold;
	}
	
	.badged[data-remaining].safe::after { color: green; }
	.badged[data-remaining].warning::after { color: yellow; }
	.badged[data-remaining].critical::after { color: red; }
	
	@media (prefers-color-scheme: dark) {
		body { background-color: #111; color: # }
		form { background-color: #222; }
		textarea { color: #ccc; }
	}
</style>

<form><textarea id=input rows=10 maxlength=4000></textarea></form>

<p style="text-align: center">
	Â© 2020 Alice Bevan-McGregor.
	<a href="https://github.com/amcgregor/paste">Released under the MIT license.</a>
</p>

<script>
	'use strict'
	
	var delay
	let input = document.getElementById('input')
	
	if ( document.location.search ) {
		input.value = decodeURIComponent(document.location.search.substr(1).replace(/\+/g, '%20'))
		tick(input)
	}
	
	function commit(origin) {
		let value = origin.value;
		let text = encodeURIComponent(value)
			.replace(/%20/g, '+')
			.replace(/%28/g, '(')
			.replace(/%29/g, ')')
			.replace(/%2C/g, ',')
			.replace(/%2E/g, '.')
			.replace(/%3A/g, ':')
			.replace(/%3D/g, '=')
			.replace(/%5B/g, '[')
			.replace(/%5D/g, ']')
			.replace(/%7B/g, '{')
			.replace(/%7D/g, '}')
			.replace(/%3B/g, ';')
		
		window.history.replaceState({}, "", window.location.origin + window.location.pathname + "?" + text)
	}
	
	function insertTab(e) {
		let target = e.target,
			shifted = e.getModifierState('Shift'),
			value = target.value
		var start = target.selectionStart,
			end = target.selectionEnd
		
		e.preventDefault();
		
		if ( !shifted && !value.substring(start, end).includes("\n") ) {
			// We do not cross a line boundary, our work is quite a bit simpler.
			// Inject a tab at the target location, or replacing selected text.
			target.value = value.substring(0, start) + "\t" + value.substring(end)
			
			// Return the insertion cursor (caret) to just after the injected tab character.
			target.selectionStart = target.selectionEnd = start + 1
			
			return
		}
		
		start = value.lastIndexOf('\n', start) + 1
		end = value.indexOf('\n', end)
		if ( end < 0 ) end = value.length;
		
		var count;  // Number of insertions or removals.
		
		if ( !shifted ) {  // Indent the selected lines.
			
			count = value.substring(start, end).match(/^/gm).length
			target.value = value.substring(0, start) +
				value.substring(start, end).replace(/^/gm, "\t") +
				value.substring(end)
			
			// Re-select the previously selected region, expanded.
			target.setSelectionRange(start, end + count)
			
		} else {  // De-dent the selected lines, which may be one if de-denting the current line.
			
			count = value.substring(start, end).match(/^\t/gm).length
			target.value = value.substring(0, start) +
				value.substring(start, end).replace(/^\t/gm, "") +
				value.substring(end)
			
			// Re-select the previously selected region, collapsed.
			target.setSelectionRange(start, end - count)
		}
	}
	
	function tick(elem) {
		if ( elem.target ) elem = elem.target
		
		elem.rows = elem.value.match(/\n/g).length + 1;
		
		var limit = elem.maxLength,
			parent = elem.parentElement,
			length = elem.value.length
		
		parent.dataset['remaining'] = limit - length
		parent.classList.remove('safe', 'warning', 'critical')
		
		if ( length < 256 )  // Our link is short enough to paste into IRC.
			parent.classList.add('safe');
		else if ( length / limit >= 0.90 )  // We've reached 90% of the limit.
			parent.classList.add('critical');
		else if ( length / limit >= 0.75 )  // Reached 75% of the limit.
			parent.classList.add('warning');
	}
	
	input.addEventListener('keydown', e => {
		if ( e.isComposing || e.keyCode === 229) return;  // Protect against IME composition events.
		if ( e.which === 9 ) insertTab(e);
	});
	
	input.addEventListener('keyup', e => {
		if ( e.isComposing || e.keyCode === 229) return;  // Protect against IME composition events.
		window.clearTimeout(delay)  // Clear any pending commit timeout.
		delay = window.setTimeout(commit, 450, input)  // Delay commit to ensure typing has stopped.
		tick(e)  // Update the maximum length calculation and input size.
	});
	
	input.parentElement.dataset['limit'] = input.maxLength
	input.parentElement.classList.add('badged')
	tick(input)  // Update our length counters and whatnot.
	commit(input)  // Canonicalize the URI.
	
	// The above will take care of "minifying" any query string given, as often URL encoding is excessive. E.g.:
	// let%20target%20%3D%20e.target%2C%0A%09start%20%3D%20target.selectionStart%2C%0A%09end%20%3D%20target.selectionEnd%2C%0A%09shifted%20%3D%20e.getModifierState%28%27Shift%27%29%2C%0A%09value%20%3D%20target.value%3B
	// let+target+=+e.target,%0A%09start+=+target.selectionStart,%0A%09end+=+target.selectionEnd,%0A%09shifted+=+e.getModifierState(%27Shift%27),%0A%09value+=+target.value;
	// 165 vs. 211 bytes, or a 21% savings.
	
	// TODO: Paste detection and automatic bulk de-indentation or indentation matching.
</script>
