<!DOCTYPE html>

<title>The most minimal pastebin in the world.</title>

<style>
	*, *:before, *:after {
		box-sizing: border-box;
		padding: 0;
		margin: 0;
		tab-size: 4;
		overflow: auto;
		outline: none;
	}
	
	body { font: 14px "Helvetica Neue", Helvetica, sans-serif; }
	body, form { padding: 15px; }
	textarea { font: 16px 'Hasklug Nerd Font Mono', 'Hasklug NF', 'Hasklug Nerd Font', Hasklig, Monofur, monospace; width: 100%; resize: none; background-color: transparent; border: none; overflow: hidden; }
	form { background-color: #eee; }
	p { margin: 10px 0 15px; }
	summary { margin-bottom: 10px; }
	
	.badged[data-remaining] { position: relative; }
	.badged[data-remaining]:after {
		content: attr(data-remaining) " / " attr(data-limit);
		display: inline-block;
		position: absolute;
		bottom: 1ex;
		right: 1ex;
		padding: 0.25ex 0.5ex;
		pointer-events: none;  /* We aren't interact-able, pass through! */
		background-color: rgba(255,255,255,0.75);
		color: #555;
		font-size: 0.8em;
		font-weight: bold;
	}
	
	.badged[data-remaining].safe::after { color: green; }
	.badged[data-remaining].warning::after { color: yellow; }
	.badged[data-remaining].critical::after { color: red; }
</style>

<form><textarea id=input rows=10 maxlength=4000></textarea></form>

<p style="text-align: center">
	Â© 2020 Alice Bevan-McGregor.
	<a href="https://github.com/amcgregor/paste">Released under the MIT license.</a>
</p>

<script>
	'use strict'
	
	var delay;
	let output = document.getElementById('output'),
		input = document.getElementById('input');
	
	if ( document.location.search ) {
		let text = decodeURIComponent(document.location.search.substr(1).replace(/\+/g, '%20'));
		
		document.getElementsByTagName('details')[0].removeAttribute('open');
		output.innerText = text;
		input.value = text;
		tick(input);
	}
	
	function commit(origin) {
		let value = origin.value;
		let text = encodeURIComponent(value).replace(/%20/g, '+').replace(/\./g, '%2E');
		
		window.history.replaceState({}, "", "/?" + text)
		output.innerText = origin.value;
	}
	
	function insertTab(e) {
		let target = e.target,
			start = target.selectionStart,
			end = target.selectionEnd,
			shifted = e.getModifierState('Shift'),
			value = target.value;
		
		e.preventDefault();
		
		if ( !shifted && !value.substring(start, end).includes("\n") ) {
			// We do not cross a line boundary, our work is quite a bit simpler.
			// Inject a tab at the target location, or replacing selected text.
			target.value = value.substring(0, start) + "\t" + value.substring(end);
			
			// Return the insertion cursor (caret) to just after the injected tab character.
			target.selectionStart = target.selectionEnd = start + 1;
			
			return;
		}
		
		// TODO: Adjust start to the actual start of the line containing the selection.
		var count;  // Number of insertions or removals.
		
		if ( !shifted ) {  // Indent the selected lines.
			
			count = value.substring(start, end).match(/^/gm).length;
			target.value = value.substring(0, start) +
				value.substring(start, end).replace(/^/gm, "\t") +
				value.substring(end)
			
			// Re-select the previously selected region, expanded.
			target.setSelectionRange(start, end + count);
			
		} else {  // De-dent the selected lines, which may be one if de-denting the current line.
			
			count = value.substring(start, end).match(/^\t/gm).length;
			target.value = value.substring(0, start) +
				value.substring(start, end).replace(/^\t/gm, "") +
				value.substring(end)
			
			// Re-select the previously selected region, collapsed.
			target.setSelectionRange(start, end - count);
		}
	}
	
	function tick(elem) {
		if ( elem.target ) elem = elem.target;
		
		elem.rows = elem.value.match(/\n/g).length + 1;
		
		var limit = elem.maxLength,
			parent = elem.parentElement,
			length = elem.value.length;
		
		parent.dataset['remaining'] = limit - length;
		parent.classList.remove('safe', 'warning', 'critical');
		
		if ( length < 256 ) {  // Our link is short enough to paste into IRC.
			parent.classList.add('safe');
		} else if ( length / limit >= 0.90 ) {  // We've reached 90% of the limit.
			parent.classList.add('critical');
		} else if ( length / limit >= 0.75 ) {  // Reached 75% of the limit.
			parent.classList.add('warning');
		}
	}
	
	input.addEventListener('keydown', e => {
		if ( e.isComposing || e.keyCode === 229) return;  // Protect against IME composition events.
		if ( e.which === 9 ) insertTab(e);
	});
	
	input.addEventListener('keyup', e => {
		if ( e.isComposing || e.keyCode === 229) return;  // Protect against IME composition events.
		window.clearTimeout(delay);  // Clear any pending commit timeout.
		delay = window.setTimeout(commit, 450, input);  // Delay commit to ensure typing has stopped.
		tick(e);  // Update the maximum length calculation and input size.
	});
	
	input.parentElement.dataset['limit'] = input.maxLength;
	input.parentElement.classList.add('badged');
	tick(input);
	
	// TODO: Paste detection and automatic bulk de-indentation or indentation matching.
</script>
